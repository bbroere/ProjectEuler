import {generateWhile, numbersWithMaxSize} from "../utilities/sequences";
import {polygonalNumber} from "../utilities/numbers";

/**
 * <p>Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:</p>
 * <table><tr><td>Triangle</td>
 * <td> </td>
 * <td>$P_{3,n}=n(n+1)/2$</td>
 * <td> </td>
 * <td>$1, 3, 6, 10, 15, \dots$</td>
 * </tr><tr><td>Square</td>
 * <td> </td>
 * <td>$P_{4,n}=n^2$</td>
 * <td> </td>
 * <td>$1, 4, 9, 16, 25, \dots$</td>
 * </tr><tr><td>Pentagonal</td>
 * <td> </td>
 * <td>$P_{5,n}=n(3n-1)/2$</td>
 * <td> </td>
 * <td>$1, 5, 12, 22, 35, \dots$</td>
 * </tr><tr><td>Hexagonal</td>
 * <td> </td>
 * <td>$P_{6,n}=n(2n-1)$</td>
 * <td> </td>
 * <td>$1, 6, 15, 28, 45, \dots$</td>
 * </tr><tr><td>Heptagonal</td>
 * <td> </td>
 * <td>$P_{7,n}=n(5n-3)/2$</td>
 * <td> </td>
 * <td>$1, 7, 18, 34, 55, \dots$</td>
 * </tr><tr><td>Octagonal</td>
 * <td> </td>
 * <td>$P_{8,n}=n(3n-2)$</td>
 * <td> </td>
 * <td>$1, 8, 21, 40, 65, \dots$</td>
 * </tr></table><p>The ordered set of three $4$-digit numbers: $8128$, $2882$, $8281$, has three interesting properties.</p>
 * <ol><li>The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).</li>
 * <li>Each polygonal type: triangle ($P_{3,127}=8128$), square ($P_{4,91}=8281$), and pentagonal ($P_{5,44}=2882$), is represented by a different number in the set.</li>
 * <li>This is the only set of $4$-digit numbers with this property.</li>
 * </ol><p>Find the sum of the only ordered set of six cyclic $4$-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.</p>
 *
 * <p>Generated on 2024-08-09 from <a href='https://projecteuler.net/problem=61'>source</a></p>
 * <p><i><b>Average runtime ~13.29 ms</b></i></p>
 */
export function run(): number {
    const allTriangleNumbers: number[] = generateWhile(polygonalNumber(3), n => n < 10000).filter(n => n >= 1000);
    const allSPolygonals: [number, number][] =
        numbersWithMaxSize(5).flatMap(
            (s: number): [number, number][] =>
                generateWhile(polygonalNumber(s + 3), n => n < 10000)
                    .filter(n => n >= 1000)
                    .map((n: number): [number, number] => [s + 3, n])
        );

    function extendCurrentMatch(currentSet: [number, number][], options: [number, number][]): [number, number][] | undefined {
        if (currentSet.length === 6) {
            if (currentSet[0][1].toString().slice(0, 2) === currentSet[5][1].toString().slice(2))
                return currentSet;
            return undefined;
        } else {
            const lastNumber: number = currentSet[currentSet.length - 1][1];
            const lastTwoDigits: string = lastNumber.toString().slice(2);
            const nextOptions: [number, number][] = options.filter(([s, n]) => n.toString().slice(0, 2) === lastTwoDigits);
            for (let i = 0; i < nextOptions.length; i++) {
                const nextOption: [number, number] = nextOptions[i];
                const newSet: [number, number][] = [...currentSet, nextOption];
                const result: [number, number][] | undefined = extendCurrentMatch(
                    newSet,
                    options.filter(([s, n]) => !newSet.map(t => t[0]).includes(s) && !newSet.map(t => t[1]).includes(n))
                );
                if (result !== undefined)
                    return result;
            }
            return undefined;
        }
    }

    for (let i = 0; i < allTriangleNumbers.length; i++) {
        const match: [number, number][] | undefined = extendCurrentMatch([[3, allTriangleNumbers[i]]], allSPolygonals);
        if (match !== undefined)
            return match.reduce((acc, [s, n]) => acc + n, 0);
    }

    return undefined;
}
